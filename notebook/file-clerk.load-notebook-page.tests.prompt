I have an endpoint that looks like: 

```
module.exports = function (app) {

  app.post('/load-notebook-page', async function (req, res) {
    if(!req.body["file-id"]){
      return res.status(400).json({ error: 'file-id is required in the request body' });
    }
    const file_id = req.body["file-id"];
    const file_path = path.join(global.root_directory, 'notebook', file_id);
    try {
      const content = await fsPromises.readFile(file_path, 'utf8');
      res.json({ content });
    } catch (err) {
      const new_file = generateNewFile(file_id);
      await fsPromises.writeFile(file_path, new_file, 'utf8', (err) => {
        if (err) {return res.status(500)}
      });
      const content = await fsPromises.readFile(file_path, 'utf8');
      res.json({ content });
    }
  });
}
```

Where app is an express.js app. 

I am using Mocha and Chai for tests. My initial code for these tests looks like: 

```js
const chai = require("chai");
const chaiHttp = require("chai-http");
const fsPromises = require("fs").promises;
const path = require("path");
const app = require('express')();  // Assuming Express is properly set up in your project
const server = require('http').Server(app);  // Create an HTTP server using the Express app
const routes_path = path.join(global.root_directory, 'routes.js');
const routes = require(routes_path)(app);
const sinon = require('sinon');


const expect = chai.expect;

chai.use(chaiHttp);

describe("File Clerk Endpoints", () => {

  describe("POST /load-notebook-page", () => {

  });

});

```

# Response 

Based on your code, it seems like you want to write tests for the "/load-notebook-page" endpoint in your Express.js app. Here's an example of how you can approach writing the tests using Mocha and Chai:

```js
const chai = require("chai");
const chaiHttp = require("chai-http");
const fsPromises = require("fs").promises;
const path = require("path");
const { createApp } = require("./app"); // Assuming you have a separate file for creating the Express app
const sinon = require("sinon");

const expect = chai.expect;
chai.use(chaiHttp);

describe("File Clerk Endpoints", () => {
  let app;
  before(() => {
    app = createApp(); // Create the Express app before running the tests
  });

  describe("POST /load-notebook-page", () => {
    it("should return 'file-id is required' error if file-id is not provided", async () => {
      const res = await chai
        .request(app)
        .post("/load-notebook-page")
        .send({}); // Send an empty request body

      expect(res).to.have.status(400);
      expect(res.body).to.deep.equal({
        error: "file-id is required in the request body",
      });
    });

    it("should return the content of the file if it exists", async () => {
      // Stub the fsPromises.readFile function to return a test content
      const readFileStub = sinon.stub(fsPromises, "readFile");
      readFileStub.resolves("Test file content");

      const res = await chai
        .request(app)
        .post("/load-notebook-page")
        .send({ "file-id": "test-file-id" });

      expect(res).to.have.status(200);
      expect(res.body.content).to.equal("Test file content");

      readFileStub.restore(); // Restore the original function
    });

    it("should create a new file and return its content if it doesn't exist", async () => {
      // Stub the fsPromises.readFile and fsPromises.writeFile functions
      const readFileStub = sinon.stub(fsPromises, "readFile");
      const writeFileStub = sinon.stub(fsPromises, "writeFile");
      readFileStub.rejects(new Error("File not found"));
      writeFileStub.resolves();

      const res = await chai
        .request(app)
        .post("/load-notebook-page")
        .send({ "file-id": "test-file-id" });

      expect(res).to.have.status(200);
      expect(res.body.content).to.equal("Generated file content");

      readFileStub.restore(); // Restore the original functions
      writeFileStub.restore();
    });
  });
});
```

In this example, I've created three test cases for the "/load-notebook-page" endpoint:

1. The first test case checks if the server returns a 400 status code and the correct error message when the "file-id" property is missing from the request body.
2. The second test case stubs the `fsPromises.readFile` function to return a test content and verifies that the server returns the expected content in the response body.
3. The third test case stubs the `fsPromises.readFile` and `fsPromises.writeFile` functions to simulate the scenario where the file doesn't exist. It verifies that the server creates a new file, returns its content in the response body, and handles the file creation error correctly.

Note that I have added a `createApp` function in the code example. In this function, you should create and configure your Express app instance. You can move your existing code for creating the app and setting up routes into this function. It's good practice to separate app creation logic from test cases to make it easier to reuse the app and mock dependencies in tests.

Hope this helps! Let me know if you have any further questions.
